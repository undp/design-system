#!/usr/bin/env node

/**
 * Generate a printable list of all available CSS custom properties
 * 
 * This script extracts CSS custom properties from the compiled CSS files
 * and formats them in a compact, grouped layout by type for easy reference.
 * Output format: --undpds-... properties grouped by category
 */

const fs = require('fs');
const path = require('path');

// Path to the compiled CSS file containing custom properties
const CSS_PATH = path.join(__dirname, '../docs/css/base-minimal.min.css');
const OUTPUT_PATH = path.join(__dirname, '../figma-tokens/css-custom-properties.md');

/**
 * Extract CSS custom properties from CSS content
 * @param {string} content - CSS file content
 * @returns {Array<string>} - Array of custom property names
 */
function extractCustomProperties(content) {
  // Match all --undpds-* custom properties (including underscores)
  const regex = /--undpds-[a-z0-9_-]+/g;
  const matches = content.match(regex) || [];
  
  // Remove duplicates and sort
  return [...new Set(matches)].sort();
}

/**
 * Group custom properties by their type/category
 * Categories: color, spacing, font-family, font-size, font-weight,
 * line-height, text-case, border, sizing, and other.
 * Empty categories are automatically removed.
 * @param {Array<string>} properties - Array of property names
 * @returns {Object} - Properties grouped by category
 */
function groupProperties(properties) {
  const groups = {
    color: [],
    spacing: [],
    'font-family': [],
    'font-size': [],
    'font-weight': [],
    'line-height': [],
    'text-case': [],
    border: [],
    sizing: [],
    other: []
  };

  properties.forEach(prop => {
    // Extract the category from property name (--undpds-{category}-...)
    const parts = prop.replace('--undpds-', '').split('-');
    
    if (parts[0] === 'color') {
      groups.color.push(prop);
    } else if (parts[0] === 'spacing') {
      groups.spacing.push(prop);
    } else if (parts[0] === 'font' && parts[1] === 'family') {
      groups['font-family'].push(prop);
    } else if (parts[0] === 'font' && parts[1] === 'size') {
      groups['font-size'].push(prop);
    } else if (parts[0] === 'font' && parts[1] === 'weight') {
      groups['font-weight'].push(prop);
    } else if (parts[0] === 'line' && parts[1] === 'height') {
      groups['line-height'].push(prop);
    } else if (parts[0] === 'text' && parts[1] === 'case') {
      groups['text-case'].push(prop);
    } else if (parts[0] === 'border') {
      groups.border.push(prop);
    } else if (parts[0] === 'sizing') {
      groups.sizing.push(prop);
    } else {
      groups.other.push(prop);
    }
  });

  // Remove empty groups
  Object.keys(groups).forEach(key => {
    if (groups[key].length === 0) {
      delete groups[key];
    }
  });

  return groups;
}

/**
 * Format properties in a compact layout
 * @param {Object} groups - Properties grouped by category
 * @returns {string} - Formatted markdown content
 */
function formatPropertiesCompact(groups) {
  const lines = [];
  
  lines.push('# CSS Custom Properties Reference');
  lines.push('');
  lines.push('This document lists all available CSS custom properties (CSS variables) in the UNDP Design System.');
  lines.push('These properties are automatically generated from Figma design tokens.');
  lines.push('');
  lines.push('**Usage:** `var(--undpds-property-name)`');
  lines.push('');
  lines.push('---');
  lines.push('');

  const totalProperties = Object.values(groups).reduce((sum, arr) => sum + arr.length, 0);
  lines.push(`**Total Properties:** ${totalProperties}`);
  lines.push('');

  // Format each group
  Object.entries(groups).forEach(([category, properties]) => {
    lines.push(`## ${category.charAt(0).toUpperCase() + category.slice(1).replace('-', ' ')} (${properties.length})`);
    lines.push('');
    
    // Format properties in columns for compact display
    // Aim for 3-4 columns depending on property name length
    // Note: Empty groups are already filtered out by groupProperties function
    const maxLength = Math.max(...properties.map(p => p.length));
    const columnsCount = maxLength > 30 ? 2 : maxLength > 20 ? 3 : 4;
    
    // Split into rows
    const rows = [];
    for (let i = 0; i < properties.length; i += columnsCount) {
      rows.push(properties.slice(i, i + columnsCount));
    }
    
    // Format as markdown list with inline code
    rows.forEach(row => {
      const formattedRow = row.map(prop => `\`${prop}\``).join(' ‚Ä¢ ');
      lines.push(formattedRow);
      lines.push('');
    });
    
    lines.push('');
  });

  lines.push('---');
  lines.push('');
  lines.push('*This file is automatically generated by `scripts/generate-css-custom-properties-list.js`*');
  lines.push('*Last updated: ' + new Date().toISOString().split('T')[0] + '*');

  return lines.join('\n');
}

/**
 * Main function
 */
function generatePropertiesList() {
  console.log('üìã Generating CSS Custom Properties List...\n');
  
  // Check if CSS file exists
  if (!fs.existsSync(CSS_PATH)) {
    console.error(`‚ùå Error: CSS file not found at ${CSS_PATH}`);
    console.error('   Please run "npm run build" first to generate the CSS files.');
    process.exit(1);
  }
  
  // Read CSS file
  console.log(`üìñ Reading CSS from: ${CSS_PATH}`);
  const cssContent = fs.readFileSync(CSS_PATH, 'utf8');
  
  // Extract custom properties
  console.log('üîç Extracting custom properties...');
  const properties = extractCustomProperties(cssContent);
  console.log(`   Found ${properties.length} unique custom properties`);
  
  // Group properties
  console.log('üìä Grouping properties by category...');
  const groups = groupProperties(properties);
  const categoryCount = Object.keys(groups).length;
  console.log(`   Organized into ${categoryCount} categories`);
  
  // Format output
  console.log('‚ú® Formatting output...');
  const output = formatPropertiesCompact(groups);
  
  // Write to file
  console.log(`üíæ Writing to: ${OUTPUT_PATH}`);
  fs.writeFileSync(OUTPUT_PATH, output, 'utf8');
  
  console.log('\n‚úÖ CSS Custom Properties list generated successfully!');
  console.log(`üìÑ Output: ${path.relative(process.cwd(), OUTPUT_PATH)}`);
  
  // Summary
  console.log('\nüìä Summary by category:');
  Object.entries(groups).forEach(([category, properties]) => {
    console.log(`   - ${category}: ${properties.length} properties`);
  });
}

// Run the script
if (require.main === module) {
  try {
    generatePropertiesList();
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Error generating properties list:');
    console.error(error);
    process.exit(1);
  }
}

module.exports = { generatePropertiesList, extractCustomProperties, groupProperties };
