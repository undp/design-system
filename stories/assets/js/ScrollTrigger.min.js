/*!
 * ScrollTrigger 3.8.0
 * https://greensock.com
 *
 * @license Copyright 2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t(exports) : typeof define === 'function' && define.amd ? define(['exports'], t) : t((e = e || self).window = e.window || {}); }(this, (e) => {
  function J(e) { return e; } function K(e) { return Fe(e)[0] || (Je(e) ? console.warn('Element not found:', e) : null); } function L(e) { return Math.round(1e5 * e) / 1e5 || 0; } function M() { return typeof window !== 'undefined'; } function N() { return Le || M() && (Le = window.gsap) && Le.registerPlugin && Le; } function O(e) { return !!~i.indexOf(e); } function P(e, t) { return ~Ue.indexOf(e) && Ue[Ue.indexOf(e) + 1][t]; } function Q(t, e) { const r = e.s; const n = e.sc; let i = v.indexOf(t); const o = n === pt.sc ? 1 : 2; return ~i || (i = v.push(t) - 1), v[i + o] || (v[i + o] = P(t, r) || (O(t) ? n : function (e) { return arguments.length ? t[r] = e : t[r]; })); } function R(e) { return P(e, 'getBoundingClientRect') || (O(e) ? function () { return yt.width = Be.innerWidth, yt.height = Be.innerHeight, yt; } : function () { return dt(e); }); } function U(e, t) { let r = t.s; const n = t.d2; const i = t.d; let o = t.a; return (r = `scroll${n}`) && (o = P(e, r)) ? o() - R(e)()[i] : O(e) ? (Ne[r] || ze[r]) - (Be[`inner${n}`] || ze[`client${n}`] || Ne[`client${n}`]) : e[r] - e[`offset${n}`]; } function V(e, t) { for (let r = 0; r < d.length; r += 3)t && !~t.indexOf(d[r + 1]) || e(d[r], d[r + 1], d[r + 2]); } function X(e) { return typeof e === 'function'; } function Y(e) { return typeof e === 'number'; } function Z(e) { return typeof e === 'object'; } function $(e) { return X(e) && e(); } function _(r, n) { return function () { const e = $(r); const t = $(n); return function () { $(e), $(t); }; }; } function aa(e, t, r) { return e && e.progress(t ? 0 : 1) && r && e.pause(); } function ba(e, t) { const r = t(e); r && r.totalTime && (e.callbackAnimation = r); } function wa(e) { return Be.getComputedStyle(e); } function ya(e, t) { for (const r in t)r in e || (e[r] = t[r]); return e; } function Aa(e, t) { const r = t.d2; return e[`offset${r}`] || e[`client${r}`] || 0; } function Ba(e) { let t; const r = []; const n = e.labels; const i = e.duration(); for (t in n)r.push(n[t] / i); return r; } function Da(n) { const i = Le.utils.snap(n); const o = Array.isArray(n) && n.slice(0).sort((e, t) => e - t); return o ? function (e, t) { let r; if (!t) return i(e); if (t > 0) { for (e -= 1e-4, r = 0; r < o.length; r++) if (o[r] >= e) return o[r]; return o[r - 1]; } for (r = o.length, e += 1e-4; r--;) if (o[r] <= e) return o[r]; return o[0]; } : function (e, t) { const r = i(e); return !t || Math.abs(r - e) < 0.001 || r - e < 0 == t < 0 ? r : i(t < 0 ? e - n : e + n); }; } function Fa(t, r, e, n) { return e.split(',').forEach((e) => t(r, e, n)); } function Ga(e, t, r) { return e.addEventListener(t, r, { passive: !0 }); } function Ha(e, t, r) { return e.removeEventListener(t, r); } function La(e, t) { if (Je(e)) { const r = e.indexOf('='); let n = ~r ? (e.charAt(r - 1) + 1) * parseFloat(e.substr(r + 1)) : 0; ~r && (e.indexOf('%') > r && (n *= t / 100), e = e.substr(0, r - 1)), e = n + (e in S ? S[e] * t : ~e.indexOf('%') ? parseFloat(e) * t / 100 : parseFloat(e) || 0); } return e; } function Ma(e, t, r, n, i, o, a, s) { const l = i.startColor; const c = i.endColor; const u = i.fontSize; const f = i.indent; const p = i.fontWeight; const d = Ie.createElement('div'); const g = O(r) || P(r, 'pinType') === 'fixed'; const h = e.indexOf('scroller') !== -1; const v = g ? Ne : r; const m = e.indexOf('start') !== -1; const b = m ? l : c; let x = `border-color:${b};font-size:${u};color:${b};font-weight:${p};pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;`; return x += `position:${(h || s) && g ? 'fixed;' : 'absolute;'}`, !h && !s && g || (x += `${n === pt ? y : w}:${o + parseFloat(f)}px;`), a && (x += `box-sizing:border-box;text-align:left;width:${a.offsetWidth}px;`), d._isStart = m, d.setAttribute('class', `gsap-marker-${e}${t ? ` marker-${t}` : ''}`), d.style.cssText = x, d.innerText = t || t === 0 ? `${e}-${t}` : e, v.children[0] ? v.insertBefore(d, v.children[0]) : v.appendChild(d), d._offset = d[`offset${n.op.d2}`], k(d, 0, n, m), d; } function Qa() { return je() - $e > 20 && G(); } function Ra() { const e = je(); $e !== e ? (G(), $e || A('scrollStart'), $e = e) : l = l || s(G); } function Sa() { return !Xe && !r && !Ie.fullscreenElement && a.restart(!0); } function Ya(e) { let t; const r = Le.ticker.frame; const n = []; let i = 0; if (g !== r || Qe) { for (z(); i < E.length; i += 4)(t = Be.matchMedia(E[i]).matches) !== E[i + 3] && ((E[i + 3] = t) ? n.push(i) : z(1, E[i]) || X(E[i + 2]) && E[i + 2]()); for (I(), i = 0; i < n.length; i++)t = n[i], Ze = E[t], E[t + 2] = E[t + 1](e); Ze = 0, o && F(0, 1), g = r, A('matchMedia'); } } function Za() { return Ha(ee, 'scrollEnd', Za) || F(!0); } function cb() { return v.forEach((e) => typeof e === 'function' && (e.rec = 0)); } function lb(e, t, r, n) { if (e.parentNode !== t) { for (var i, o = H.length, a = t.style, s = e.style; o--;)a[i = H[o]] = r[i]; a.position = r.position === 'absolute' ? 'absolute' : 'relative', r.display === 'inline' && (a.display = 'inline-block'), s[w] = s[y] = 'auto', a.overflow = 'visible', a.boxSizing = 'border-box', a[tt] = Aa(e, ft) + ut, a[rt] = Aa(e, pt) + ut, a[st] = s[lt] = s.top = s[b] = '0', xt(n), s[tt] = s.maxWidth = r[tt], s[rt] = s.maxHeight = r[rt], s[st] = r[st], e.parentNode.insertBefore(t, e), t.appendChild(e); } } function ob(e) { for (var t = W.length, r = e.style, n = [], i = 0; i < t; i++)n.push(W[i], r[W[i]]); return n.t = e, n; } function rb(e, t, r, n, i, o, a, s, l, c, u, f, p) { X(e) && (e = e(s)), Je(e) && e.substr(0, 3) === 'max' && (e = f + (e.charAt(4) === '=' ? La(`0${e.substr(3)}`, r) : 0)); let d; let g; let h; const v = p ? p.time() : 0; if (p && p.seek(0), Y(e))a && k(a, r, n, !0); else { X(t) && (t = t(s)); let m; let b; let x; let y; const w = e.split(' '); h = K(t) || Ne, (m = dt(h) || {}) && (m.left || m.top) || wa(h).display !== 'none' || (y = h.style.display, h.style.display = 'block', m = dt(h), y ? h.style.display = y : h.style.removeProperty('display')), b = La(w[0], m[n.d]), x = La(w[1] || '0', r), e = m[n.p] - l[n.p] - c + b + i - x, a && k(a, x, n, r - x < 20 || a._isStart && x > 20), r -= r - x; } if (o) { const S = e + r; const T = o._isStart; d = `scroll${n.d2}`, k(o, S, n, T && S > 20 || !T && (u ? Math.max(Ne[d], ze[d]) : o.parentNode[d]) <= S + 1), u && (l = dt(a), u && (o.style[n.op.p] = l[n.op.p] - n.op.m - o._offset + ut)); } return p && h && (d = dt(h), p.seek(f), g = dt(h), p._caScrollDist = d[n.p] - g[n.p], e = e / p._caScrollDist * f), p && p.seek(v), p ? e : Math.round(e); } function tb(e, t, r, n) { if (e.parentNode !== t) { let i; let o; const a = e.style; if (t === Ne) { for (i in e._stOrig = a.cssText, o = wa(e))+i || q.test(i) || !o[i] || typeof a[i] !== 'string' || i === '0' || (a[i] = o[i]); a.top = r, a.left = n; } else a.cssText = e._stOrig; Le.core.getCache(e).uncache = 1, t.appendChild(e); } } function ub(l, e) { function xf(e, t, r, n, i) { let o = xf.tween; const a = t.onComplete; const s = {}; return o && o.kill(), c = Math.round(r), t[p] = e, (t.modifiers = s)[p] = function (e) { return (e = L(f())) !== c && e !== u && Math.abs(e - c) > 2 ? (o.kill(), xf.tween = 0) : e = r + n * o.ratio + i * o.ratio * o.ratio, u = c, c = L(e); }, t.onComplete = function () { xf.tween = 0, a && a.call(o); }, o = xf.tween = Le.to(l, t); } let c; let u; var f = Q(l, e); var p = `_scroll${e.p2}`; return l[p] = f, l.addEventListener('wheel', () => xf.tween && xf.tween.kill() && (xf.tween = 0), { passive: !0 }), xf; } let Le; let o; let Be; let Ie; let ze; let Ne; let i; let a; let s; let l; let Fe; let De; let Ge; let c; let Xe; let He; let u; let Ye; let f; let p; let d; let Ke; let Ve; let r; let We; let Ze; let g; let h; var Qe = 1; var Ue = []; var v = []; var je = Date.now; let m = je(); var $e = 0; let qe = 1; var Je = function _isString(e) { return typeof e === 'string'; }; const et = Math.abs; const t = 'scrollLeft'; const n = 'scrollTop'; var b = 'left'; var y = 'right'; var w = 'bottom'; var tt = 'width'; var rt = 'height'; const nt = 'Right'; const it = 'Left'; const ot = 'Top'; const at = 'Bottom'; var st = 'padding'; var lt = 'margin'; const ct = 'Width'; const x = 'Height'; var ut = 'px'; var ft = {
    s: t, p: b, p2: it, os: y, os2: nt, d: tt, d2: ct, a: 'x', sc: function sc(e) { return arguments.length ? Be.scrollTo(e, pt.sc()) : Be.pageXOffset || Ie[t] || ze[t] || Ne[t] || 0; },
  }; var pt = {
    s: n, p: 'top', p2: ot, os: w, os2: at, d: rt, d2: x, a: 'y', op: ft, sc: function sc(e) { return arguments.length ? Be.scrollTo(ft.sc(), e) : Be.pageYOffset || Ie[n] || ze[n] || Ne[n] || 0; },
  }; var dt = function _getBounds(e, t) {
    const r = t && wa(e)[u] !== 'matrix(1, 0, 0, 1, 0, 0)' && Le.to(e, {
      x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0,
    }).progress(1); const n = e.getBoundingClientRect(); return r && r.progress(0).kill(), n;
  }; const gt = {
    startColor: 'green', endColor: 'red', indent: 0, fontSize: '16px', fontWeight: 'normal',
  }; const ht = { toggleActions: 'play', anticipatePin: 0 }; var S = {
    top: 0, left: 0, center: 0.5, bottom: 1, right: 1,
  }; var k = function _positionMarker(e, t, r, n) { const i = { display: 'block' }; const o = r[n ? 'os2' : 'p2']; const a = r[n ? 'p2' : 'os2']; e._isFlipped = n, i[`${r.a}Percent`] = n ? -100 : 0, i[r.a] = n ? '1px' : 0, i[`border${o}${ct}`] = 1, i[`border${a}${ct}`] = 0, i[r.p] = `${t}px`, Le.set(e, i); }; const vt = []; const mt = {}; const T = {}; const C = []; var E = []; var A = function _dispatch(e) { return T[e] && T[e].map((e) => e()) || C; }; const B = []; var I = function _revertRecorded(e) { for (let t = 0; t < B.length; t += 5)e && B[t + 4] !== e || (B[t].style.cssText = B[t + 1], B[t].getBBox && B[t].setAttribute('transform', B[t + 2] || ''), B[t + 3].uncache = 1); }; var z = function _revertAll(e, t) { let r; for (Ye = 0; Ye < vt.length; Ye++)r = vt[Ye], t && r.media !== t || (e ? r.kill(1) : r.revert()); t && I(t), t || A('revert'); }; var F = function _refreshAll(e, t) { if (!$e || e) { h = !0; const r = A('refreshInit'); Ke && ee.sort(), t || z(), vt.forEach((e) => e.refresh()), r.forEach((e) => e && e.render && e.render(-1)), cb(), a.pause(), h = !1, A('refresh'); } else Ga(ee, 'scrollEnd', Za); }; let D = 0; let bt = 1; var G = function _updateAll() { if (!h) { const e = vt.length; const t = je(); const r = t - m >= 50; const n = e && vt[0].scroll(); if (bt = n < D ? -1 : 1, D = n, r && ($e && !He && t - $e > 200 && ($e = 0, A('scrollEnd')), Ge = m, m = t), bt < 0) { for (Ye = e; Ye-- > 0;)vt[Ye] && vt[Ye].update(0, r); bt = 1; } else for (Ye = 0; Ye < e; Ye++)vt[Ye] && vt[Ye].update(0, r); l = 0; } }; var H = [b, 'top', w, y, lt + at, lt + nt, lt + ot, lt + it, 'display', 'flexShrink', 'float', 'zIndex', 'grid-column-start', 'grid-column-end', 'grid-row-start', 'grid-row-end', 'grid-area', 'justify-self', 'align-self', 'place-self']; var W = H.concat([tt, rt, 'boxSizing', `max${ct}`, `max${x}`, 'position', lt, st, st + ot, st + nt, st + at, st + it]); const j = /([A-Z])/g; var xt = function _setState(e) { if (e) { let t; let r; const n = e.t.style; const i = e.length; let o = 0; for ((e.t._gsap || Le.core.getCache(e.t)).uncache = 1; o < i; o += 2)r = e[o + 1], t = e[o], r ? n[t] = r : n[t] && n.removeProperty(t.replace(j, '-$1').toLowerCase()); } }; var yt = { left: 0, top: 0 }; var q = /(?:webkit|moz|length|cssText|inset)/i; ft.op = pt; var ee = (ScrollTrigger.prototype.init = function init(T, k) {
    if (this.progress = this.start = 0, this.vars && this.kill(1), qe) {
      let m; let n; let f; let _; let C; let M; let E; let A; let L; let B; let I; let e; let z; let N; let F; let D; let G; let t; let H; let b; let V; let W; let x; let j; let y; let w; let r; let S; let $; let q; let i; let p; let ee; let te; let re; let ne; let ie; const oe = (T = ya(Je(T) || Y(T) || T.nodeType ? { trigger: T } : T, ht)).onUpdate; let ae = T.toggleClass; let o = T.id; const se = T.onToggle; const le = T.onRefresh; const ce = T.scrub; let ue = T.trigger; let fe = T.pin; let pe = T.pinSpacing; const de = T.invalidateOnRefresh; let ge = T.anticipatePin; const a = T.onScrubComplete; const d = T.onSnapComplete; const he = T.once; let ve = T.snap; const me = T.pinReparent; let s = T.pinSpacer; const be = T.containerAnimation; const xe = T.fastScrollEnd; const ye = T.preventOverlaps; const we = T.horizontal || T.containerAnimation && !1 !== T.horizontal ? ft : pt; const Se = !ce && ce !== 0; const Te = K(T.scroller || Be); const l = Le.core.getCache(Te); const Oe = O(Te); const ke = ('pinType' in T ? T.pinType : P(Te, 'pinType') || Oe && 'fixed') === 'fixed'; const _e = [T.onEnter, T.onLeave, T.onEnterBack, T.onLeaveBack]; const Ce = Se && T.toggleActions.split(' '); const c = 'markers' in T ? T.markers : ht.markers; const Me = Oe ? 0 : parseFloat(wa(Te)[`border${we.p2}${ct}`]) || 0; const Pe = this; const u = T.onRefreshInit && function () { return T.onRefreshInit(Pe); }; const Ee = (function _getSizeFunc(e, t, r) { const n = r.d; const i = r.d2; let o = r.a; return (o = P(e, 'getBoundingClientRect')) ? function () { return o()[n]; } : function () { return (t ? Be[`inner${i}`] : e[`client${i}`]) || 0; }; }(Te, Oe, we)); const Ae = (function _getOffsetsFunc(e, t) { return !t || ~Ue.indexOf(e) ? R(e) : function () { return yt; }; }(Te, Oe)); let g = 0; const Re = Q(Te, we); if (Pe.media = Ze, ge *= 45, Pe.scroller = Te, Pe.scroll = be ? be.time.bind(be) : Re, _ = Re(), Pe.vars = T, k = k || T.animation, 'refreshPriority' in T && (Ke = 1), l.tweenScroll = l.tweenScroll || { top: ub(Te, pt), left: ub(Te, ft) }, Pe.tweenTo = m = l.tweenScroll[we.p], k && (k.vars.lazy = !1, k._initted || !1 !== k.vars.immediateRender && !1 !== T.immediateRender && k.render(0, !0, !0), Pe.animation = k.pause(), k.scrollTrigger = Pe, (i = Y(ce) && ce) && (q = Le.to(k, { ease: 'power3', duration: i, onComplete: function onComplete() { return a && a(Pe); } })), S = 0, o = o || k.vars.id), vt.push(Pe), ve && (Z(ve) && !ve.push || (ve = { snapTo: ve }), 'scrollBehavior' in Ne.style && Le.set(Oe ? [Ne, ze] : Te, { scrollBehavior: 'auto' }), f = X(ve.snapTo) ? ve.snapTo : ve.snapTo === 'labels' ? (function _getClosestLabel(t) { return function (e) { return Le.utils.snap(Ba(t), e); }; }(k)) : ve.snapTo === 'labelsDirectional' ? (function _getLabelAtDirection(r) { return function (e, t) { return Da(Ba(r))(e, t.direction); }; }(k)) : !1 !== ve.directional ? function (e, t) { return Da(ve.snapTo)(e, t.direction); } : Le.utils.snap(ve.snapTo), p = ve.duration || { min: 0.1, max: 2 }, p = Z(p) ? De(p.min, p.max) : De(p, p), ee = Le.delayedCall(ve.delay || i / 2 || 0.1, () => {
        if (Math.abs(Pe.getVelocity()) < 10 && !He && g !== Re()) {
          const e = k && !Se ? k.totalProgress() : Pe.progress; const t = (e - $) / (je() - Ge) * 1e3 || 0; let r = Le.utils.clamp(-Pe.progress, 1 - Pe.progress, et(t / 2) * t / 0.185); const n = Pe.progress + (!1 === ve.inertia ? 0 : r); const i = De(0, 1, f(n, Pe)); const o = Re(); const a = Math.round(M + i * z); const s = ve.onStart; const l = ve.onInterrupt; const c = ve.onComplete; const u = m.tween; if (o <= E && M <= o && a !== o) {
            if (u && !u._initted && u.data <= et(a - o)) return; !1 === ve.inertia && (r = i - Pe.progress), m(a, {
              duration: p(et(0.185 * Math.max(et(n - e), et(i - e)) / t / 0.05 || 0)), ease: ve.ease || 'power3', data: et(a - o), onInterrupt: function onInterrupt() { return ee.restart(!0) && l && l(Pe); }, onComplete: function onComplete() { g = Re(), S = $ = k && !Se ? k.totalProgress() : Pe.progress, d && d(Pe), c && c(Pe); },
            }, o, r * z, a - o - r * z), s && s(Pe, m.tween);
          }
        } else Pe.isActive && ee.restart(!0);
      }).pause()), o && (mt[o] = Pe), ue = Pe.trigger = K(ue || fe), fe = !0 === fe ? ue : K(fe), Je(ae) && (ae = { targets: ue, className: ae }), fe && (!1 === pe || pe === lt || (pe = !(!pe && wa(fe.parentNode).display === 'flex') && st), Pe.pin = fe, !1 !== T.force3D && Le.set(fe, { force3D: !0 }), (n = Le.core.getCache(fe)).spacer ? N = n.pinState : (s && ((s = K(s)) && !s.nodeType && (s = s.current || s.nativeElement), n.spacerIsNative = !!s, s && (n.spacerState = ob(s))), n.spacer = G = s || Ie.createElement('div'), G.classList.add('pin-spacer'), o && G.classList.add(`pin-spacer-${o}`), n.pinState = N = ob(fe)), Pe.spacer = G = n.spacer, r = wa(fe), x = r[pe + we.os2], H = Le.getProperty(fe), b = Le.quickSetter(fe, we.a, ut), lb(fe, G, r), D = ob(fe)), c && (e = Z(c) ? ya(c, gt) : gt, B = Ma('scroller-start', o, Te, we, e, 0), I = Ma('scroller-end', o, Te, we, e, 0, B), t = B[`offset${we.op.d2}`], A = Ma('start', o, Te, we, e, t, 0, be), L = Ma('end', o, Te, we, e, t, 0, be), be && (ie = Le.quickSetter([A, L], we.a, ut)), ke || Ue.length && !0 === P(Te, 'fixedMarkers') || ((function _makePositionable(e) { const t = wa(e).position; e.style.position = t === 'absolute' || t === 'fixed' ? t : 'relative'; }(Oe ? Ne : Te)), Le.set([B, I], { force3D: !0 }), y = Le.quickSetter(B, we.a, ut), w = Le.quickSetter(I, we.a, ut))), be) { const h = be.vars.onUpdate; const v = be.vars.onUpdateParams; be.eventCallback('onUpdate', () => { Pe.update(0, 0, 1), h && h.apply(v || []); }); }Pe.previous = function () { return vt[vt.indexOf(Pe) - 1]; }, Pe.next = function () { return vt[vt.indexOf(Pe) + 1]; }, Pe.revert = function (e) { const t = !1 !== e || !Pe.enabled; const r = Xe; t !== Pe.isReverted && (t && (Pe.scroll.rec || (Pe.scroll.rec = Re()), re = Math.max(Re(), Pe.scroll.rec || 0), te = Pe.progress, ne = k && k.progress()), A && [A, L, B, I].forEach((e) => e.style.display = t ? 'none' : 'block'), t && (Xe = 1), Pe.update(t), Xe = r, fe && (t ? (function _swapPinOut(e, t, r) { xt(r); const n = e._gsap; if (n.spacerIsNative)xt(n.spacerState); else if (e.parentNode === t) { const i = t.parentNode; i && (i.insertBefore(e, t), i.removeChild(t)); } }(fe, G, N)) : me && Pe.isActive || lb(fe, G, wa(fe), j)), Pe.isReverted = t); }, Pe.refresh = function (e, t) {
        if (!Xe && Pe.enabled || t) {
          if (fe && e && $e)Ga(ScrollTrigger, 'scrollEnd', Za); else {
            Xe = 1, q && q.pause(), de && k && k.progress(0).invalidate(), Pe.isReverted || Pe.revert(); for (var r, n, i, o, a, s, l, c, u, f, p = Ee(), d = Ae(), g = be ? be.duration() : U(Te, we), h = 0, v = 0, m = T.end, b = T.endTrigger || ue, x = T.start || (T.start !== 0 && ue ? fe ? '0 0' : '0 100%' : 0), y = T.pinnedContainer && K(T.pinnedContainer), w = ue && Math.max(0, vt.indexOf(Pe)) || 0, S = w; S--;)(s = vt[S]).end || s.refresh(0, 1) || (Xe = 1), !(l = s.pin) || l !== ue && l !== fe || s.isReverted || ((f = f || []).unshift(s), s.revert()); for (X(x) && (x = x(Pe)), M = rb(x, ue, p, we, Re(), A, B, Pe, d, Me, ke, g, be) || (fe ? -0.001 : 0), X(m) && (m = m(Pe)), Je(m) && !m.indexOf('+=') && (~m.indexOf(' ') ? m = (Je(x) ? x.split(' ')[0] : '') + m : (h = La(m.substr(2), p), m = Je(x) ? x : M + h, b = ue)), E = Math.max(M, rb(m || (b ? '100% 0' : g), b, p, we, Re() + h, L, I, Pe, d, Me, ke, g, be)) || -0.001, z = E - M || (M -= 0.01) && 0.001, h = 0, S = w; S--;)(l = (s = vt[S]).pin) && s.start - s._pinPush < M && !be && (r = s.end - s.start, l !== ue && l !== y || Y(x) || (h += r), l === fe && (v += r)); if (M += h, E += h, Pe._pinPush = v, A && h && ((r = {})[we.a] = `+=${h}`, y && (r[we.p] = `-=${Re()}`), Le.set([A, L], r)), fe) {
              r = wa(fe), o = we === pt, i = Re(), V = parseFloat(H(we.a)) + v, !g && E > 1 && ((Oe ? Ne : Te).style[`overflow-${we.a}`] = 'scroll'), lb(fe, G, r), D = ob(fe), n = dt(fe, !0), c = ke && Q(Te, o ? ft : pt)(), pe && ((j = [pe + we.os2, z + v + ut]).t = G, (S = pe === st ? Aa(fe, we) + z + v : 0) && j.push(we.d, S + ut), xt(j), ke && Re(re)), ke && ((a = {
                top: n.top + (o ? i - M : c) + ut, left: n.left + (o ? c : i - M) + ut, boxSizing: 'border-box', position: 'fixed',
              })[tt] = a.maxWidth = Math.ceil(n.width) + ut, a[rt] = a.maxHeight = Math.ceil(n.height) + ut, a[lt] = a[lt + ot] = a[lt + nt] = a[lt + at] = a[lt + it] = '0', a[st] = r[st], a[st + ot] = r[st + ot], a[st + nt] = r[st + nt], a[st + at] = r[st + at], a[st + it] = r[st + it], F = (function _copyState(e, t, r) { for (var n, i = [], o = e.length, a = r ? 8 : 0; a < o; a += 2)n = e[a], i.push(n, n in t ? t[n] : e[a + 1]); return i.t = e.t, i; }(N, a, me))), k ? (u = k._initted, Ve(1), k.render(k.duration(), !0, !0), W = H(we.a) - V + z + v, z !== W && F.splice(F.length - 2, 2), k.render(0, !0, !0), u || k.invalidate(), Ve(0)) : W = z;
            } else if (ue && Re() && !be) for (n = ue.parentNode; n && n !== Ne;)n._pinOffset && (M -= n._pinOffset, E -= n._pinOffset), n = n.parentNode; f && f.forEach((e) => e.revert(!1)), Pe.start = M, Pe.end = E, _ = C = Re(), be || (_ < re && Re(re), Pe.scroll.rec = 0), Pe.revert(!1), Xe = 0, k && Se && k._initted && k.progress() !== ne && k.progress(ne, !0).render(k.time(), !0, !0), te !== Pe.progress && (k && !Se && k.totalProgress(te, !0), Pe.progress = te, Pe.update(0, 0, 1)), fe && pe && (G._pinOffset = Math.round(Pe.progress * W)), le && le(Pe);
          }
        }
      }, Pe.getVelocity = function () { return (Re() - C) / (je() - Ge) * 1e3 || 0; }, Pe.endAnimation = function () { aa(Pe.callbackAnimation), k && (q ? q.progress(1) : k.paused() ? Se || aa(k, Pe.direction < 0, 1) : aa(k, k.reversed())); }, Pe.getTrailing = function (t) { const e = vt.indexOf(Pe); const r = Pe.direction > 0 ? vt.slice(0, e).reverse() : vt.slice(e + 1); return Je(t) ? r.filter((e) => e.vars.preventOverlaps === t) : r; }, Pe.update = function (e, t, r) { if (!be || r || e) { let n; let i; let o; let a; let s; let l; let c; const u = Pe.scroll(); const f = e ? 0 : (u - M) / z; let p = f < 0 ? 0 : f > 1 ? 1 : f || 0; const d = Pe.progress; if (t && (C = _, _ = be ? Re() : u, ve && ($ = S, S = k && !Se ? k.totalProgress() : p)), ge && !p && fe && !Xe && !Qe && $e && M < u + (u - C) / (je() - Ge) * ge && (p = 1e-4), p !== d && Pe.enabled) { if (a = (s = (n = Pe.isActive = !!p && p < 1) != (!!d && d < 1)) || !!p != !!d, Pe.direction = d < p ? 1 : -1, Pe.progress = p, a && !Xe && (i = p && !d ? 0 : p === 1 ? 1 : d === 1 ? 2 : 3, Se && (o = !s && Ce[i + 1] !== 'none' && Ce[i + 1] || Ce[i], c = k && (o === 'complete' || o === 'reset' || o in k))), ye && s && (c || ce || !k) && (X(ye) ? ye(Pe) : Pe.getTrailing(ye).forEach((e) => e.endAnimation())), Se || (!q || Xe || Qe ? k && k.totalProgress(p, !!Xe) : (q.vars.totalProgress = p, q.invalidate().restart())), fe) if (e && pe && (G.style[pe + we.os2] = x), ke) { if (a) { if (l = !e && d < p && u < E + 1 && u + 1 >= U(Te, we), me) if (e || !n && !l)tb(fe, G); else { const g = dt(fe, !0); const h = u - M; tb(fe, Ne, g.top + (we === pt ? h : 0) + ut, g.left + (we === pt ? 0 : h) + ut); }xt(n || l ? F : D), W !== z && p < 1 && n || b(V + (p !== 1 || l ? 0 : W)); } } else b(V + W * p); !ve || m.tween || Xe || Qe || ee.restart(!0), ae && (s || he && p && (p < 1 || !We)) && Fe(ae.targets).forEach((e) => e.classList[n || he ? 'add' : 'remove'](ae.className)), !oe || Se || e || oe(Pe), a && !Xe ? (Se && (c && (o === 'complete' ? k.pause().totalProgress(1) : o === 'reset' ? k.restart(!0).pause() : o === 'restart' ? k.restart(!0) : k[o]()), oe && oe(Pe)), !s && We || (se && s && ba(Pe, se), _e[i] && ba(Pe, _e[i]), he && (p === 1 ? Pe.kill(!1, 1) : _e[i] = 0), s || _e[i = p === 1 ? 1 : 3] && ba(Pe, _e[i])), xe && !n && Math.abs(Pe.getVelocity()) > (Y(xe) ? xe : 2500) && (aa(Pe.callbackAnimation), q ? q.progress(1) : aa(k, !p, 1))) : Se && oe && !Xe && oe(Pe); } if (w) { const v = be ? u / be.duration() * (be._caScrollDist || 0) : u; y(v + (B._isFlipped ? 1 : 0)), w(v); }ie && ie(-u / be.duration() * (be._caScrollDist || 0)); } }, Pe.enable = function (e, t) { Pe.enabled || (Pe.enabled = !0, Ga(Te, 'resize', Sa), Ga(Te, 'scroll', Ra), u && Ga(ScrollTrigger, 'refreshInit', u), !1 !== e && (Pe.progress = te = 0, _ = C = g = Re()), !1 !== t && Pe.refresh()); }, Pe.getTween = function (e) { return e && m ? m.tween : q; }, Pe.disable = function (e, t) { if (Pe.enabled && (!1 !== e && Pe.revert(), Pe.enabled = Pe.isActive = !1, t || q && q.pause(), re = 0, n && (n.uncache = 1), u && Ha(ScrollTrigger, 'refreshInit', u), ee && (ee.pause(), m.tween && m.tween.kill() && (m.tween = 0)), !Oe)) { for (let r = vt.length; r--;) if (vt[r].scroller === Te && vt[r] !== Pe) return; Ha(Te, 'resize', Sa), Ha(Te, 'scroll', Ra); } }, Pe.kill = function (e, t) { Pe.disable(e, t), q && q.kill(), o && delete mt[o]; let r = vt.indexOf(Pe); vt.splice(r, 1), r === Ye && bt > 0 && Ye--, r = 0, vt.forEach((e) => e.scroller === Pe.scroller && (r = 1)), r || (Pe.scroll.rec = 0), k && (k.scrollTrigger = null, e && k.render(-1), t || k.kill()), A && [A, L, B, I].forEach((e) => e.parentNode && e.parentNode.removeChild(e)), fe && (n && (n.uncache = 1), r = 0, vt.forEach((e) => e.pin === fe && r++), r || (n.spacer = 0)); }, Pe.enable(!1, !1), k && k.add && !z ? Le.delayedCall(0.01, () => M || E || Pe.refresh()) && (z = 0.01) && (M = E = 0) : Pe.refresh();
    } else this.update = this.refresh = this.kill = J;
  }, ScrollTrigger.register = function register(e) { if (!o && (Le = e || N(), M() && window.document && (Be = window, Ie = document, ze = Ie.documentElement, Ne = Ie.body), Le && (Fe = Le.utils.toArray, De = Le.utils.clamp, Ve = Le.core.suppressOverwrites || J, Le.core.globals('ScrollTrigger', ScrollTrigger), Ne))) { s = Be.requestAnimationFrame || function (e) { return setTimeout(e, 16); }, Ga(Be, 'wheel', Ra), i = [Be, Ie, ze, Ne], Ga(Ie, 'scroll', Ra); let t; const r = Ne.style; const n = r.borderTopStyle; r.borderTopStyle = 'solid', t = dt(Ne), pt.m = Math.round(t.top + pt.sc()) || 0, ft.m = Math.round(t.left + ft.sc()) || 0, n ? r.borderTopStyle = n : r.removeProperty('border-top-style'), c = setInterval(Qa, 200), Le.delayedCall(0.5, () => Qe = 0), Ga(Ie, 'touchcancel', J), Ga(Ne, 'touchstart', J), Fa(Ga, Ie, 'pointerdown,touchstart,mousedown', () => He = 1), Fa(Ga, Ie, 'pointerup,touchend,mouseup', () => He = 0), u = Le.utils.checkPrefix('transform'), W.push(u), o = je(), a = Le.delayedCall(0.2, F).pause(), d = [Ie, 'visibilitychange', function () { const e = Be.innerWidth; const t = Be.innerHeight; Ie.hidden ? (f = e, p = t) : f === e && p === t || Sa(); }, Ie, 'DOMContentLoaded', F, Be, 'load', function () { return $e || F(); }, Be, 'resize', Sa], V(Ga); } return o; }, ScrollTrigger.defaults = function defaults(e) { for (const t in e)ht[t] = e[t]; }, ScrollTrigger.kill = function kill() { qe = 0, vt.slice(0).forEach((e) => e.kill(1)); }, ScrollTrigger.config = function config(e) { 'limitCallbacks' in e && (We = !!e.limitCallbacks); const t = e.syncInterval; t && clearInterval(c) || (c = t) && setInterval(Qa, t), 'autoRefreshEvents' in e && (V(Ha) || V(Ga, e.autoRefreshEvents || 'none'), r = (`${e.autoRefreshEvents}`).indexOf('resize') === -1); }, ScrollTrigger.scrollerProxy = function scrollerProxy(e, t) { const r = K(e); const n = v.indexOf(r); const i = O(r); ~n && v.splice(n, i ? 6 : 2), i ? Ue.unshift(Be, t, Ne, t, ze, t) : Ue.unshift(r, t); }, ScrollTrigger.matchMedia = function matchMedia(e) { let t; let r; let n; let i; let o; for (r in e)n = E.indexOf(r), i = e[r], (Ze = r) === 'all' ? i() : (t = Be.matchMedia(r)) && (t.matches && (o = i()), ~n ? (E[n + 1] = _(E[n + 1], i), E[n + 2] = _(E[n + 2], o)) : (n = E.length, E.push(r, i, o), t.addListener ? t.addListener(Ya) : t.addEventListener('change', Ya)), E[n + 3] = t.matches), Ze = 0; return E; }, ScrollTrigger.clearMatchMedia = function clearMatchMedia(e) { e || (E.length = 0), (e = E.indexOf(e)) >= 0 && E.splice(e, 4); }, ScrollTrigger.isInViewport = function isInViewport(e, t, r) { const n = (Je(e) ? K(e) : e).getBoundingClientRect(); const i = n[r ? tt : rt] * t || 0; return r ? n.right - i > 0 && n.left + i < Be.innerWidth : n.bottom - i > 0 && n.top + i < Be.innerHeight; }, ScrollTrigger.positionInViewport = function positionInViewport(e, t, r) { Je(e) && (e = K(e)); const n = e.getBoundingClientRect(); const i = n[r ? tt : rt]; const o = t == null ? i / 2 : t in S ? S[t] * i : ~t.indexOf('%') ? parseFloat(t) * i / 100 : parseFloat(t) || 0; return r ? (n.left + o) / Be.innerWidth : (n.top + o) / Be.innerHeight; }, ScrollTrigger); function ScrollTrigger(e, t) { o || ScrollTrigger.register(Le) || console.warn('Please gsap.registerPlugin(ScrollTrigger)'), this.init(e, t); }ee.version = '3.8.0', ee.saveStyles = function (e) { return e ? Fe(e).forEach((e) => { if (e && e.style) { const t = B.indexOf(e); t >= 0 && B.splice(t, 5), B.push(e, e.style.cssText, e.getBBox && e.getAttribute('transform'), Le.core.getCache(e), Ze); } }) : B; }, ee.revert = function (e, t) { return z(!e, t); }, ee.create = function (e, t) { return new ee(e, t); }, ee.refresh = function (e) { return e ? Sa() : (o || ee.register()) && F(!0); }, ee.update = G, ee.clearScrollMemory = cb, ee.maxScroll = function (e, t) { return U(e, t ? ft : pt); }, ee.getScrollFunc = function (e, t) { return Q(K(e), t ? ft : pt); }, ee.getById = function (e) { return mt[e]; }, ee.getAll = function () { return vt.slice(0); }, ee.isScrolling = function () { return !!$e; }, ee.snapDirectional = Da, ee.addEventListener = function (e, t) { const r = T[e] || (T[e] = []); ~r.indexOf(t) || r.push(t); }, ee.removeEventListener = function (e, t) { const r = T[e]; const n = r && r.indexOf(t); n >= 0 && r.splice(n, 1); }, ee.batch = function (e, t) { function Lj(e, t) { let r = []; let n = []; const i = Le.delayedCall(o, () => { t(r, n), r = [], n = []; }).pause(); return function (e) { r.length || i.restart(!0), r.push(e.trigger), n.push(e), a <= r.length && i.progress(1); }; } let r; const n = []; const i = {}; var o = t.interval || 0.016; var a = t.batchMax || 1e9; for (r in t)i[r] = r.substr(0, 2) === 'on' && X(t[r]) && r !== 'onRefreshInit' ? Lj(0, t[r]) : t[r]; return X(a) && (a = a(), Ga(ee, 'refresh', () => a = t.batchMax())), Fe(e).forEach((e) => { const t = {}; for (r in i)t[r] = i[r]; t.trigger = e, n.push(ee.create(t)); }), n; }, ee.sort = function (e) { return vt.sort(e || ((e, t) => -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0)))); }, N() && Le.registerPlugin(ee), e.ScrollTrigger = ee, e.default = ee; if (typeof (window) === 'undefined' || window !== e) { Object.defineProperty(e, '__esModule', { value: !0 }); } else { delete e.default; }
}));
